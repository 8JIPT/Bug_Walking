<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/Source/Game.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/Source/Game.cpp" />
              <option name="originalContent" value="// ----------------------------------------------------------------&#10;// From Game Programming in C++ by Sanjay Madhav&#10;// Copyright (C) 2017 Sanjay Madhav. All rights reserved.&#10;// &#10;// Released under the BSD License&#10;// See LICENSE in root directory for full details.&#10;// ----------------------------------------------------------------&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;map&gt;&#10;#include &lt;fstream&gt;&#10;#include &quot;CSV.h&quot;&#10;#include &quot;Game.h&quot;&#10;#include &quot;Components/Drawing/DrawComponent.h&quot;&#10;#include &quot;Components/Physics/RigidBodyComponent.h&quot;&#10;#include &quot;Random.h&quot;&#10;#include &quot;Actors/Actor.h&quot;&#10;#include &quot;Actors/Block.h&quot;&#10;#include &quot;Actors/Goomba.h&quot;&#10;#include &quot;Actors/Spawner.h&quot;&#10;#include &quot;Actors/Robot.h&quot;&#10;#include &quot;Actors/Mushroom.h&quot;&#10;#include &quot;Actors/Chaser.h&quot;&#10;#include &quot;Actors/ChaserSpawner.h&quot;&#10;#include &quot;Actors/Walker.h&quot;&#10;#include &quot;Actors/WalkerSpawner.h&quot;&#10;#include &quot;Actors/GoldRing.h&quot;&#10;#include &quot;AudioSystem.h&quot;&#10;#include &quot;UI/Screens/HUD.h&quot;&#10;#include &quot;UI/Screens/MainMenu.h&quot;&#10;#include &quot;UI/Screens/PauseMenu.h&quot;&#10;#include &quot;UI/Screens/GameOver.h&quot;&#10;#include &quot;UI/Screens/Win.h&quot;&#10;#include &quot;UI/Screens/CrossFadeScreen.h&quot;&#10;&#10;Game::Game()&#10;        :mWindow(nullptr)&#10;        ,mRenderer(nullptr)&#10;        ,mTicksCount(0)&#10;        ,mIsRunning(true)&#10;        ,mIsDebugging(true)&#10;        ,mUpdatingActors(false)&#10;        ,mCameraPos(Vector2::Zero)&#10;        ,mRobot(nullptr)&#10;        ,mAudio(nullptr)&#10;        ,mHUD(nullptr)&#10;        ,mLevelData(nullptr)&#10;        ,mIsPaused(false)&#10;        ,mIsSceneTransitioning(false)&#10;        ,mMusicHandle(SoundHandle::Invalid)&#10;{&#10;&#10;}&#10;&#10;bool Game::Initialize()&#10;{&#10;    Random::Init();&#10;&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0)&#10;    {&#10;        SDL_Log(&quot;Unable to initialize SDL: %s&quot;, SDL_GetError());&#10;        return false;&#10;    }&#10;&#10;    // Init SDL Image&#10;    int imgFlags = IMG_INIT_PNG;&#10;    if (!(IMG_Init(imgFlags) &amp; imgFlags))&#10;    {&#10;        SDL_Log(&quot;Unable to initialize SDL_image: %s&quot;, IMG_GetError());&#10;        return false;&#10;    }&#10;&#10;    // Initialize SDL_ttf&#10;    if (TTF_Init() != 0)&#10;    {&#10;        SDL_Log(&quot;Failed to initialize SDL_ttf&quot;);&#10;        return false;&#10;    }&#10;&#10;    // Initialize SDL_mixer&#10;    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) == -1)&#10;    {&#10;        SDL_Log(&quot;Failed to initialize SDL_mixer: %s&quot;, Mix_GetError());&#10;        return false;&#10;    }&#10;&#10;    mWindow = SDL_CreateWindow(&quot;Bug Walking&quot;,SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,WINDOW_WIDTH, WINDOW_HEIGHT,SDL_WINDOW_OPENGL);&#10;    if (!mWindow)&#10;    {&#10;        SDL_Log(&quot;Failed to create window: %s&quot;, SDL_GetError());&#10;        return false;&#10;    }&#10;&#10;    mRenderer = new Renderer(mWindow);&#10;    mRenderer-&gt;Initialize(WINDOW_WIDTH, WINDOW_HEIGHT);&#10;&#10;    mAudio = new AudioSystem();&#10;&#10;    LoadSounds();&#10;&#10;    // Start with main menu scene&#10;    SetScene(GameScene::MainMenu);&#10;&#10;    mTicksCount = SDL_GetTicks();&#10;&#10;    return true;&#10;}&#10;&#10;void Game::InitializeActors()&#10;{&#10;    // Load and build level for playing scene&#10;    mLevelData = LoadLevel(&quot;../Assets/Levels/level1/level1.csv&quot;, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;    if (mLevelData) BuildLevel(mLevelData, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;}&#10;&#10;void Game::UnloadScene()&#10;{&#10;    // Set all actors to destroy so they will be deleted in UpdateActors&#10;    for (auto* actor : mActors) {&#10;        actor-&gt;SetState(ActorState::Destroy);&#10;    }&#10;&#10;    // Delete UI screens (preserve crossfade if present)&#10;    auto iter = mUIStack.begin();&#10;    while (iter != mUIStack.end()) {&#10;        if (dynamic_cast&lt;CrossFadeScreen*&gt;(*iter) != nullptr) {&#10;            ++iter;&#10;        } else {&#10;            // Check if this is the HUD before deleting&#10;            if (*iter == mHUD) {&#10;                mHUD = nullptr;&#10;            }&#10;            delete *iter;&#10;            iter = mUIStack.erase(iter);&#10;        }&#10;    }&#10;&#10;    // Delete level data (if any)&#10;    if (mLevelData) {&#10;        for (int i = 0; i &lt; LEVEL_HEIGHT; ++i) {&#10;            delete[] mLevelData[i];&#10;        }&#10;        delete[] mLevelData;&#10;        mLevelData = nullptr;&#10;    }&#10;&#10;    // Reset pointers&#10;    mRobot = nullptr;&#10;    // HUD already deleted in the UI stack loop above&#10;    mHUD = nullptr;&#10;}&#10;&#10;void Game::SetScene(GameScene nextScene)&#10;{&#10;    mIsSceneTransitioning = true;&#10;&#10;    // If we are not paused, unload current scene so the new one starts clean.&#10;    if (!mIsPaused) UnloadScene();&#10;&#10;    switch (nextScene) {&#10;        case GameScene::MainMenu: {&#10;            auto* menu = new MainMenu(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            // Start music if not already playing&#10;            if (mMusicHandle == SoundHandle::Invalid || mAudio-&gt;GetSoundState(mMusicHandle) != SoundState::Playing) {&#10;                mMusicHandle = mAudio-&gt;PlaySound(&quot;S31-The Gears of Progress.ogg&quot;, true);&#10;            }&#10;            break;&#10;        }&#10;        case GameScene::Level1: {&#10;            // Reset camera to start position&#10;            mCameraPos = Vector2::Zero;&#10;            mCameraLeftBoundary = 0.0f;&#10;            &#10;            // Initialize level and HUD&#10;            mLevelData = LoadLevel(&quot;../Assets/Levels/level1/level1.csv&quot;, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;            if (mLevelData) BuildLevel(mLevelData, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;&#10;            mHUD = new HUD(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mRobot &amp;&amp; mHUD)&#10;            {&#10;                mHUD-&gt;SetHealth(mRobot-&gt;GetHitPoints());&#10;            }&#10;            break;&#10;        }&#10;        case GameScene::PauseMenu: {&#10;            auto* pauseMenu = new PauseMenu(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;PauseSound(mMusicHandle);&#10;            break;&#10;        }&#10;        case GameScene::GameOver: {&#10;            auto* gameOver = new GameOver(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;StopSound(mMusicHandle);&#10;            break;&#10;        }&#10;        case GameScene::Win: {&#10;            auto* winScreen = new Win(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;StopSound(mMusicHandle);&#10;            break;&#10;        }&#10;        default:&#10;            SDL_Log(&quot;Unknown scene.&quot;);&#10;            break;&#10;    }&#10;&#10;    mIsSceneTransitioning = false;&#10;}&#10;&#10;int **Game::LoadLevel(const std::string&amp; fileName, int width, int height)&#10;{&#10;    int** level = new int*[height];&#10;    for (int i = 0; i &lt; height; ++i) {&#10;        level[i] = new int[width];&#10;        for (int j = 0; j &lt; width; ++j) {&#10;            level[i][j] = -1;&#10;        }&#10;    }&#10;&#10;    std::ifstream file(fileName);&#10;    if (!file.is_open()) {&#10;        SDL_Log(&quot;Failed to open level file: %s&quot;, fileName.c_str());&#10;        return nullptr;&#10;    }&#10;    std::string line;&#10;    int row = 0;&#10;    while (std::getline(file, line) &amp;&amp; row &lt; height){&#10;        std::vector&lt;int&gt; tiles = CSVHelper::Split(line);&#10;        for (int col = 0; col &lt; width &amp;&amp; col &lt; tiles.size(); ++col){&#10;            level[row][col] = tiles[col];&#10;        }&#10;        ++row;&#10;    }&#10;&#10;    return level;&#10;}&#10;&#10;TiledTileInfo Game::DecodeTiledID(uint32_t raw)&#10;{&#10;    const uint32_t FLIP_H = 0x80000000;&#10;    const uint32_t FLIP_V = 0x40000000;&#10;    const uint32_t FLIP_D = 0x20000000;&#10;    const uint32_t TILE_ID_MASK = 0x1FFFFFFF;&#10;&#10;    TiledTileInfo tile;&#10;&#10;    tile.flipH = (raw &amp; FLIP_H) != 0;&#10;    tile.flipV = (raw &amp; FLIP_V) != 0;&#10;    tile.flipD = (raw &amp; FLIP_D) != 0;&#10;&#10;    // Obtain the real ID&#10;    tile.id = raw &amp; TILE_ID_MASK;&#10;&#10;    return tile;&#10;}&#10;&#10;void Game::BuildLevel(int** levelData, int width, int height){&#10;    for (int row = 0; row &lt; height; ++row){&#10;        for (int col = 0; col &lt; width; ++col){&#10;            int rawID = levelData[row][col];&#10;            if (rawID == -1) continue;  // Empty tile&#10;            TiledTileInfo info;&#10;            info = DecodeTiledID(static_cast&lt;uint32_t&gt;(rawID));&#10;            Block* block = nullptr;&#10;            Vector2 position(col * TILE_SIZE + TILE_SIZE * 0.5f, row * TILE_SIZE + TILE_SIZE * 0.5f);&#10;            std::string baseAddr = &quot;../Assets/Sprites/Blocks&quot;;&#10;            switch (info.id){&#10;                case 222:{//Mario&#10;                    mRobot = new Robot(this);&#10;                    mRobot-&gt;SetPosition(position);&#10;                    break;&#10;                }&#10;                case 237: {//Chaser&#10;                    ChaserSpawner* spawnerC = new ChaserSpawner(this, SPAWN_DISTANCE);&#10;                    spawnerC-&gt;SetPosition(position);&#10;                    break;&#10;                }&#10;                case 238: {//Walker&#10;                    WalkerSpawner* spawnerW = new WalkerSpawner(this, position);&#10;                    break;&#10;                }&#10;                default:&#10;                    // For regular tiles, use the CSV value directly for the filename&#10;                    std::string blockAddr = &quot;/Free Industrial Zone Tileset/1 Tiles/IndustrialTile_&quot;;&#10;                    if (info.id &lt; 10) blockAddr += &quot;0&quot; + std::to_string(info.id + 1) + &quot;.png&quot;;&#10;                    else blockAddr += std::to_string(info.id + 1) + &quot;.png&quot;;&#10;                    block = new Block(this, baseAddr + blockAddr);&#10;                    block-&gt;SetPosition(position);&#10;                    break;&#10;            }&#10;            if (block)&#10;            {&#10;                block-&gt;SetFlip(info.flipH, info.flipV, info.flipD);&#10;            }&#10;        }&#10;    }&#10;    // Adiciona 10 GoldRings aleat贸rios ap贸s construir o mapa&#10;    SpawnRandomGoldRings(10, width, height, levelData);&#10;}&#10;&#10;void Game::LoadSounds() {&#10;&#10;    mDeadChunk       = Mix_LoadWAV(&quot;../Assets/Sounds/Dead.wav&quot;);&#10;    mJumpChunk       = Mix_LoadWAV(&quot;../Assets/Sounds/Jump.wav&quot;);&#10;    mShootChunk   = Mix_LoadWAV(&quot;../Assets/Sounds/Laser_Shoot.wav&quot;);&#10;    mStageClearChunk = Mix_LoadWAV(&quot;../Assets/Sounds/StageClear.wav&quot;);&#10;    mGlitchChunk     = Mix_LoadWAV(&quot;../Assets/Sounds/Glitch.flac&quot;);&#10;&#10;    if (!mGlitchChunk) {&#10;        SDL_Log(&quot;Falha ao carregar Glitch.flac: %s&quot;, Mix_GetError());&#10;    }&#10;}&#10;&#10;void Game::PlayDeadChunk() {&#10;&#10;&#10;}&#10;&#10;void Game::PlayJumpChunk() const {&#10;&#10;    Mix_PlayChannel(-1, mJumpChunk, 0);&#10;}&#10;&#10;void Game::PlayShootChunk() const {&#10;&#10;    Mix_PlayChannel(-1, mShootChunk, 0);&#10;}&#10;&#10;void Game::PlayStageClearChunk() {&#10;&#10;&#10;}&#10;&#10;void Game::PlayGlitchChunk() const {&#10;    if (mGlitchChunk) {&#10;        Mix_PlayChannel(-1, mGlitchChunk, 0);&#10;    }&#10;}&#10;&#10;void Game::RunLoop()&#10;{&#10;    while (mIsRunning)&#10;    {&#10;        // Calculate delta time in seconds&#10;        float deltaTime = (SDL_GetTicks() - mTicksCount) / 1000.0f;&#10;        if (deltaTime &gt; 0.05f)&#10;        {&#10;            deltaTime = 0.05f;&#10;        }&#10;&#10;        mTicksCount = SDL_GetTicks();&#10;&#10;        ProcessInput();&#10;        UpdateGame(deltaTime);&#10;        GenerateOutput();&#10;&#10;        // Sleep to maintain frame rate&#10;        int sleepTime = (1000 / FPS) - (SDL_GetTicks() - mTicksCount);&#10;        if (sleepTime &gt; 0)&#10;        {&#10;            SDL_Delay(sleepTime);&#10;        }&#10;    }&#10;}&#10;&#10;void Game::ProcessInput()&#10;{&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event))&#10;    {&#10;        switch (event.type)&#10;        {&#10;            case SDL_QUIT:&#10;                Quit();&#10;                break;&#10;            case SDL_KEYDOWN:&#10;                if (!event.key.repeat){&#10;                    // Check for pause menu toggle first (only if in-game with only HUD)&#10;                    if (event.key.keysym.sym == SDLK_RETURN &amp;&amp; mRobot != nullptr){&#10;                        bool onlyHUD = true;&#10;                        for (auto* ui : mUIStack) {&#10;                            if (dynamic_cast&lt;HUD*&gt;(ui) == nullptr) {&#10;                                onlyHUD = false;&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (onlyHUD) {&#10;                            mIsPaused = true;&#10;                            SetScene(GameScene::PauseMenu);&#10;                            break;&#10;                        }&#10;                    }&#10;                    // Let topmost UI handle key press&#10;                    if (!mUIStack.empty()){&#10;                        mUIStack.back()-&gt;HandleKeyPress(event.key.keysym.sym);&#10;                    }&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;    const Uint8* state = SDL_GetKeyboardState(nullptr);&#10;&#10;    for (auto actor : mActors)&#10;    {&#10;        actor-&gt;ProcessInput(state);&#10;    }&#10;}&#10;&#10;void Game::UpdateGame(float deltaTime)&#10;{&#10;    if (!mIsPaused &amp;&amp; !mIsSceneTransitioning) {&#10;        // Update all actors and pending actors&#10;        UpdateActors(deltaTime);&#10;&#10;        // Update audio system&#10;        if (mAudio) mAudio-&gt;Update(deltaTime);&#10;&#10;        // Check if Mario is dead&#10;        if (mRobot &amp;&amp; mRobot-&gt;IsDead()) {&#10;            SetScene(GameScene::GameOver);&#10;            return;&#10;        }&#10;&#10;        // Update camera position&#10;        UpdateCamera();&#10;    }&#10;&#10;    // Update UI screens (active ones)&#10;    for (auto ui : mUIStack) {&#10;        if (ui-&gt;GetState() == UIScreen::UIState::Active) {&#10;            ui-&gt;Update(deltaTime);&#10;        }&#10;    }&#10;&#10;    // Delete any UI that are closed&#10;    auto iter = mUIStack.begin();&#10;    while (iter != mUIStack.end()) {&#10;        if ((*iter)-&gt;GetState() == UIScreen::UIState::Closing) {&#10;            delete *iter;&#10;            iter = mUIStack.erase(iter);&#10;        } else {&#10;            ++iter;&#10;        }&#10;    }&#10;}&#10;&#10;void Game::UpdateActors(float deltaTime)&#10;{&#10;    mUpdatingActors = true;&#10;    for (auto actor : mActors)&#10;    {&#10;        actor-&gt;Update(deltaTime);&#10;    }&#10;    mUpdatingActors = false;&#10;&#10;    for (auto pending : mPendingActors)&#10;    {&#10;        mActors.emplace_back(pending);&#10;    }&#10;    mPendingActors.clear();&#10;&#10;    std::vector&lt;Actor*&gt; deadActors;&#10;    for (auto actor : mActors)&#10;    {&#10;        if (actor-&gt;GetState() == ActorState::Destroy)&#10;        {&#10;            if (std::find(deadActors.begin(), deadActors.end(), actor) == deadActors.end()) deadActors.emplace_back(actor);&#10;        }&#10;    }&#10;    for (auto actor : deadActors) {&#10;        const auto&amp; comps = actor-&gt;GetComponents();&#10;        SDL_Log(&quot;Deleting actor at %p, type=%s, numComponents=%zu&quot;, actor, actor-&gt;GetName(), comps.size());&#10;    }&#10;    for (auto actor : deadActors)&#10;    {&#10;        //SDL_Log(&quot;Deleting actor at %p, type=%s&quot;, actor, actor-&gt;GetName());&#10;        RemoveActor(actor);&#10;        delete actor;&#10;    }&#10;}&#10;&#10;void Game::UpdateCamera()&#10;{&#10;    if (!mRobot) {&#10;        return;&#10;    }&#10;&#10;    float robotX = mRobot-&gt;GetPosition().x;&#10;    float robotY = mRobot-&gt;GetPosition().y;&#10;&#10;    float targetX = robotX - WINDOW_WIDTH / 2.0f + TILE_SIZE / 2.0f;&#10;    float targetY = robotY - WINDOW_HEIGHT / 2.0f + TILE_SIZE / 2.0f;&#10;&#10;    if (targetX &gt; mCameraLeftBoundary)&#10;        mCameraLeftBoundary = targetX;&#10;&#10;    targetX = mCameraLeftBoundary;&#10;&#10;    float levelWidthInPixels = LEVEL_WIDTH * TILE_SIZE;&#10;    float levelHeightInPixels = LEVEL_HEIGHT * TILE_SIZE;&#10;&#10;    if (targetX &lt; 0) targetX = 0;&#10;    if (targetX &gt; levelWidthInPixels - WINDOW_WIDTH) targetX = levelWidthInPixels - WINDOW_WIDTH;&#10;&#10;    if (targetY &lt; 0) targetY = 0;&#10;    if (targetY &gt; levelHeightInPixels - WINDOW_HEIGHT) targetY = levelHeightInPixels - WINDOW_HEIGHT;&#10;&#10;    mCameraPos.x = targetX;&#10;    mCameraPos.y = targetY;&#10;}&#10;&#10;void Game::AddActor(Actor* actor)&#10;{&#10;    if (mUpdatingActors)&#10;    {&#10;        mPendingActors.emplace_back(actor);&#10;    }&#10;    else&#10;    {&#10;        mActors.emplace_back(actor);&#10;    }&#10;}&#10;&#10;void Game::RemoveActor(Actor* actor)&#10;{&#10;    auto iter = std::find(mPendingActors.begin(), mPendingActors.end(), actor);&#10;    if (iter != mPendingActors.end())&#10;    {&#10;        // Swap to end of vector and pop off (avoid erase copies)&#10;        std::iter_swap(iter, mPendingActors.end() - 1);&#10;        mPendingActors.pop_back();&#10;    }&#10;&#10;    iter = std::find(mActors.begin(), mActors.end(), actor);&#10;    if (iter != mActors.end())&#10;    {&#10;        // Swap to end of vector and pop off (avoid erase copies)&#10;        std::iter_swap(iter, mActors.end() - 1);&#10;        mActors.pop_back();&#10;    }&#10;}&#10;&#10;void Game::AddDrawable(class DrawComponent *drawable)&#10;{&#10;    mDrawables.emplace_back(drawable);&#10;&#10;    std::sort(mDrawables.begin(), mDrawables.end(),[](DrawComponent* a, DrawComponent* b) {&#10;        return a-&gt;GetDrawOrder() &lt; b-&gt;GetDrawOrder();&#10;    });&#10;}&#10;&#10;void Game::RemoveDrawable(class DrawComponent *drawable)&#10;{&#10;    auto iter = std::find(mDrawables.begin(), mDrawables.end(), drawable);&#10;    mDrawables.erase(iter);&#10;}&#10;&#10;void Game::AddCollider(class AABBColliderComponent* collider)&#10;{&#10;    mColliders.emplace_back(collider);&#10;}&#10;&#10;void Game::RemoveCollider(AABBColliderComponent* collider)&#10;{&#10;    auto iter = std::find(mColliders.begin(), mColliders.end(), collider);&#10;    mColliders.erase(iter);&#10;}&#10;&#10;void Game::GenerateOutput()&#10;{&#10;    // Clear back buffer&#10;    mRenderer-&gt;Clear();&#10;&#10;    //background drawing (only when in gameplay)&#10;    if (mRobot) {&#10;        Texture* bgTexture = mRenderer-&gt;GetTexture(&quot;../Assets/Sprites/Background.png&quot;);&#10;        if (bgTexture){&#10;            Vector2 size(LEVEL_WIDTH * TILE_SIZE, LEVEL_HEIGHT * TILE_SIZE);&#10;&#10;            Vector2 topLeft = Vector2(LEVEL_WIDTH * TILE_SIZE / 2.0f, LEVEL_HEIGHT * TILE_SIZE / 2.0f);&#10;            mRenderer-&gt;DrawTexture(topLeft, size, 0.0f, Vector3::One, bgTexture, Vector4::UnitRect, mCameraPos, false);&#10;        }&#10;    }&#10;&#10;    for (auto drawable : mDrawables)&#10;    {&#10;        drawable-&gt;Draw(mRenderer);&#10;&#10;        if(mIsDebugging)&#10;        {&#10;           // Call draw for actor components&#10;              for (auto comp : drawable-&gt;GetOwner()-&gt;GetComponents())&#10;              {&#10;                comp-&gt;DebugDraw(mRenderer);&#10;              }&#10;        }&#10;    }&#10;&#10;    // Draw UI elements&#10;    mRenderer-&gt;Draw();&#10;&#10;    // Swap front buffer and back buffer&#10;    mRenderer-&gt;Present();&#10;}&#10;&#10;void Game::Shutdown()&#10;{&#10;    // Delete actors (destructors should call RemoveActor safely)&#10;    while (!mActors.empty()) {&#10;        delete mActors.back();&#10;    }&#10;&#10;    // Delete UI screens&#10;    for (auto ui : mUIStack) {&#10;        delete ui;&#10;    }&#10;    mUIStack.clear();&#10;&#10;    // Delete level data if still present&#10;    if (mLevelData) {&#10;        for (int i = 0; i &lt; LEVEL_HEIGHT; ++i) {&#10;            delete[] mLevelData[i];&#10;        }&#10;        delete[] mLevelData;&#10;        mLevelData = nullptr;&#10;    }&#10;&#10;    // Renderer cleanup&#10;    if (mRenderer) {&#10;        mRenderer-&gt;Shutdown();&#10;        delete mRenderer;&#10;        mRenderer = nullptr;&#10;    }&#10;&#10;    // Audio cleanup&#10;    if (mAudio) {&#10;        delete mAudio;&#10;        mAudio = nullptr;&#10;    }&#10;&#10;    if (mWindow) {&#10;        SDL_DestroyWindow(mWindow);&#10;        mWindow = nullptr;&#10;    }&#10;&#10;    Mix_FreeChunk(mDeadChunk);&#10;    Mix_FreeChunk(mJumpChunk);&#10;    Mix_FreeChunk(mShootChunk);&#10;    Mix_FreeChunk(mStageClearChunk);&#10;    Mix_FreeChunk(mGlitchChunk);&#10;&#10;    Mix_CloseAudio();&#10;&#10;    SDL_Quit();&#10;}&#10;&#10;void Game::SpawnRandomGoldRings(int quantidade, int width, int height, int** levelData) {&#10;    int tentativas = 0;&#10;    int maxTentativas = quantidade * 10;&#10;    int ringsCriados = 0;&#10;    while (ringsCriados &lt; quantidade &amp;&amp; tentativas &lt; maxTentativas) {&#10;        int col = rand() % width;&#10;        int row = rand() % height;&#10;        if (levelData[row][col] == -1) { // Tile vazio&#10;            Vector2 pos(col * TILE_SIZE + TILE_SIZE * 0.5f, row * TILE_SIZE + TILE_SIZE * 0.5f);&#10;            GoldRing* ring = new GoldRing(this);&#10;            ring-&gt;SetPosition(pos);&#10;            ringsCriados++;&#10;        }&#10;        tentativas++;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="// ----------------------------------------------------------------&#10;// From Game Programming in C++ by Sanjay Madhav&#10;// Copyright (C) 2017 Sanjay Madhav. All rights reserved.&#10;// &#10;// Released under the BSD License&#10;// See LICENSE in root directory for full details.&#10;// ----------------------------------------------------------------&#10;&#10;#include &lt;algorithm&gt;&#10;#include &lt;vector&gt;&#10;#include &lt;map&gt;&#10;#include &lt;fstream&gt;&#10;#include &quot;CSV.h&quot;&#10;#include &quot;Game.h&quot;&#10;#include &quot;Components/Drawing/DrawComponent.h&quot;&#10;#include &quot;Components/Physics/RigidBodyComponent.h&quot;&#10;#include &quot;Random.h&quot;&#10;#include &quot;Actors/Actor.h&quot;&#10;#include &quot;Actors/Block.h&quot;&#10;#include &quot;Actors/Goomba.h&quot;&#10;#include &quot;Actors/Spawner.h&quot;&#10;#include &quot;Actors/Robot.h&quot;&#10;#include &quot;Actors/Mushroom.h&quot;&#10;#include &quot;Actors/Chaser.h&quot;&#10;#include &quot;Actors/ChaserSpawner.h&quot;&#10;#include &quot;Actors/Walker.h&quot;&#10;#include &quot;Actors/WalkerSpawner.h&quot;&#10;#include &quot;Actors/GoldRing.h&quot;&#10;#include &quot;AudioSystem.h&quot;&#10;#include &quot;UI/Screens/HUD.h&quot;&#10;#include &quot;UI/Screens/MainMenu.h&quot;&#10;#include &quot;UI/Screens/PauseMenu.h&quot;&#10;#include &quot;UI/Screens/GameOver.h&quot;&#10;#include &quot;UI/Screens/Win.h&quot;&#10;#include &quot;UI/Screens/CrossFadeScreen.h&quot;&#10;&#10;Game::Game()&#10;        :mWindow(nullptr)&#10;        ,mRenderer(nullptr)&#10;        ,mTicksCount(0)&#10;        ,mIsRunning(true)&#10;        ,mIsDebugging(false)&#10;        ,mUpdatingActors(false)&#10;        ,mCameraPos(Vector2::Zero)&#10;        ,mRobot(nullptr)&#10;        ,mAudio(nullptr)&#10;        ,mHUD(nullptr)&#10;        ,mLevelData(nullptr)&#10;        ,mIsPaused(false)&#10;        ,mIsSceneTransitioning(false)&#10;        ,mMusicHandle(SoundHandle::Invalid)&#10;{&#10;&#10;}&#10;&#10;bool Game::Initialize()&#10;{&#10;    Random::Init();&#10;&#10;    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0)&#10;    {&#10;        SDL_Log(&quot;Unable to initialize SDL: %s&quot;, SDL_GetError());&#10;        return false;&#10;    }&#10;&#10;    // Init SDL Image&#10;    int imgFlags = IMG_INIT_PNG;&#10;    if (!(IMG_Init(imgFlags) &amp; imgFlags))&#10;    {&#10;        SDL_Log(&quot;Unable to initialize SDL_image: %s&quot;, IMG_GetError());&#10;        return false;&#10;    }&#10;&#10;    // Initialize SDL_ttf&#10;    if (TTF_Init() != 0)&#10;    {&#10;        SDL_Log(&quot;Failed to initialize SDL_ttf&quot;);&#10;        return false;&#10;    }&#10;&#10;    // Initialize SDL_mixer&#10;    if (Mix_OpenAudio(44100, MIX_DEFAULT_FORMAT, 2, 2048) == -1)&#10;    {&#10;        SDL_Log(&quot;Failed to initialize SDL_mixer: %s&quot;, Mix_GetError());&#10;        return false;&#10;    }&#10;&#10;    mWindow = SDL_CreateWindow(&quot;Bug Walking&quot;,SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,WINDOW_WIDTH, WINDOW_HEIGHT,SDL_WINDOW_OPENGL);&#10;    if (!mWindow)&#10;    {&#10;        SDL_Log(&quot;Failed to create window: %s&quot;, SDL_GetError());&#10;        return false;&#10;    }&#10;&#10;    mRenderer = new Renderer(mWindow);&#10;    mRenderer-&gt;Initialize(WINDOW_WIDTH, WINDOW_HEIGHT);&#10;&#10;    mAudio = new AudioSystem();&#10;&#10;    LoadSounds();&#10;&#10;    // Start with main menu scene&#10;    SetScene(GameScene::MainMenu);&#10;&#10;    mTicksCount = SDL_GetTicks();&#10;&#10;    return true;&#10;}&#10;&#10;void Game::InitializeActors()&#10;{&#10;    // Load and build level for playing scene&#10;    mLevelData = LoadLevel(&quot;../Assets/Levels/level1/level1.csv&quot;, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;    if (mLevelData) BuildLevel(mLevelData, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;}&#10;&#10;void Game::UnloadScene()&#10;{&#10;    // Set all actors to destroy so they will be deleted in UpdateActors&#10;    for (auto* actor : mActors) {&#10;        actor-&gt;SetState(ActorState::Destroy);&#10;    }&#10;&#10;    // Delete UI screens (preserve crossfade if present)&#10;    auto iter = mUIStack.begin();&#10;    while (iter != mUIStack.end()) {&#10;        if (dynamic_cast&lt;CrossFadeScreen*&gt;(*iter) != nullptr) {&#10;            ++iter;&#10;        } else {&#10;            // Check if this is the HUD before deleting&#10;            if (*iter == mHUD) {&#10;                mHUD = nullptr;&#10;            }&#10;            delete *iter;&#10;            iter = mUIStack.erase(iter);&#10;        }&#10;    }&#10;&#10;    // Delete level data (if any)&#10;    if (mLevelData) {&#10;        for (int i = 0; i &lt; LEVEL_HEIGHT; ++i) {&#10;            delete[] mLevelData[i];&#10;        }&#10;        delete[] mLevelData;&#10;        mLevelData = nullptr;&#10;    }&#10;&#10;    // Reset pointers&#10;    mRobot = nullptr;&#10;    // HUD already deleted in the UI stack loop above&#10;    mHUD = nullptr;&#10;}&#10;&#10;void Game::SetScene(GameScene nextScene)&#10;{&#10;    mIsSceneTransitioning = true;&#10;&#10;    // If we are not paused, unload current scene so the new one starts clean.&#10;    if (!mIsPaused) UnloadScene();&#10;&#10;    switch (nextScene) {&#10;        case GameScene::MainMenu: {&#10;            auto* menu = new MainMenu(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            // Start music if not already playing&#10;            if (mMusicHandle == SoundHandle::Invalid || mAudio-&gt;GetSoundState(mMusicHandle) != SoundState::Playing) {&#10;                mMusicHandle = mAudio-&gt;PlaySound(&quot;S31-The Gears of Progress.ogg&quot;, true);&#10;            }&#10;            break;&#10;        }&#10;        case GameScene::Level1: {&#10;            // Reset camera to start position&#10;            mCameraPos = Vector2::Zero;&#10;            mCameraLeftBoundary = 0.0f;&#10;            &#10;            // Initialize level and HUD&#10;            mLevelData = LoadLevel(&quot;../Assets/Levels/level1/level1.csv&quot;, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;            if (mLevelData) BuildLevel(mLevelData, LEVEL_WIDTH, LEVEL_HEIGHT);&#10;&#10;            mHUD = new HUD(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mRobot &amp;&amp; mHUD)&#10;            {&#10;                mHUD-&gt;SetHealth(mRobot-&gt;GetHitPoints());&#10;            }&#10;            break;&#10;        }&#10;        case GameScene::PauseMenu: {&#10;            auto* pauseMenu = new PauseMenu(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;PauseSound(mMusicHandle);&#10;            break;&#10;        }&#10;        case GameScene::GameOver: {&#10;            auto* gameOver = new GameOver(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;StopSound(mMusicHandle);&#10;            break;&#10;        }&#10;        case GameScene::Win: {&#10;            auto* winScreen = new Win(this, &quot;../Assets/Fonts/Silver.ttf&quot;);&#10;            if (mAudio) mAudio-&gt;StopSound(mMusicHandle);&#10;            break;&#10;        }&#10;        default:&#10;            SDL_Log(&quot;Unknown scene.&quot;);&#10;            break;&#10;    }&#10;&#10;    mIsSceneTransitioning = false;&#10;}&#10;&#10;int **Game::LoadLevel(const std::string&amp; fileName, int width, int height)&#10;{&#10;    int** level = new int*[height];&#10;    for (int i = 0; i &lt; height; ++i) {&#10;        level[i] = new int[width];&#10;        for (int j = 0; j &lt; width; ++j) {&#10;            level[i][j] = -1;&#10;        }&#10;    }&#10;&#10;    std::ifstream file(fileName);&#10;    if (!file.is_open()) {&#10;        SDL_Log(&quot;Failed to open level file: %s&quot;, fileName.c_str());&#10;        return nullptr;&#10;    }&#10;    std::string line;&#10;    int row = 0;&#10;    while (std::getline(file, line) &amp;&amp; row &lt; height){&#10;        std::vector&lt;int&gt; tiles = CSVHelper::Split(line);&#10;        for (int col = 0; col &lt; width &amp;&amp; col &lt; tiles.size(); ++col){&#10;            level[row][col] = tiles[col];&#10;        }&#10;        ++row;&#10;    }&#10;&#10;    return level;&#10;}&#10;&#10;TiledTileInfo Game::DecodeTiledID(uint32_t raw)&#10;{&#10;    const uint32_t FLIP_H = 0x80000000;&#10;    const uint32_t FLIP_V = 0x40000000;&#10;    const uint32_t FLIP_D = 0x20000000;&#10;    const uint32_t TILE_ID_MASK = 0x1FFFFFFF;&#10;&#10;    TiledTileInfo tile;&#10;&#10;    tile.flipH = (raw &amp; FLIP_H) != 0;&#10;    tile.flipV = (raw &amp; FLIP_V) != 0;&#10;    tile.flipD = (raw &amp; FLIP_D) != 0;&#10;&#10;    // Obtain the real ID&#10;    tile.id = raw &amp; TILE_ID_MASK;&#10;&#10;    return tile;&#10;}&#10;&#10;void Game::BuildLevel(int** levelData, int width, int height){&#10;    for (int row = 0; row &lt; height; ++row){&#10;        for (int col = 0; col &lt; width; ++col){&#10;            int rawID = levelData[row][col];&#10;            if (rawID == -1) continue;  // Empty tile&#10;            TiledTileInfo info;&#10;            info = DecodeTiledID(static_cast&lt;uint32_t&gt;(rawID));&#10;            Block* block = nullptr;&#10;            Vector2 position(col * TILE_SIZE + TILE_SIZE * 0.5f, row * TILE_SIZE + TILE_SIZE * 0.5f);&#10;            std::string baseAddr = &quot;../Assets/Sprites/Blocks&quot;;&#10;            switch (info.id){&#10;                case 222:{//Mario&#10;                    mRobot = new Robot(this);&#10;                    mRobot-&gt;SetPosition(position);&#10;                    break;&#10;                }&#10;                case 237: {//Chaser&#10;                    ChaserSpawner* spawnerC = new ChaserSpawner(this, SPAWN_DISTANCE);&#10;                    spawnerC-&gt;SetPosition(position);&#10;                    break;&#10;                }&#10;                case 238: {//Walker&#10;                    WalkerSpawner* spawnerW = new WalkerSpawner(this, position);&#10;                    break;&#10;                }&#10;                default:&#10;                    // For regular tiles, use the CSV value directly for the filename&#10;                    std::string blockAddr = &quot;/Free Industrial Zone Tileset/1 Tiles/IndustrialTile_&quot;;&#10;                    if (info.id &lt; 10) blockAddr += &quot;0&quot; + std::to_string(info.id + 1) + &quot;.png&quot;;&#10;                    else blockAddr += std::to_string(info.id + 1) + &quot;.png&quot;;&#10;                    block = new Block(this, baseAddr + blockAddr);&#10;                    block-&gt;SetPosition(position);&#10;                    break;&#10;            }&#10;            if (block)&#10;            {&#10;                block-&gt;SetFlip(info.flipH, info.flipV, info.flipD);&#10;            }&#10;        }&#10;    }&#10;    // Adiciona 10 GoldRings aleat贸rios ap贸s construir o mapa&#10;    SpawnRandomGoldRings(10, width, height, levelData);&#10;}&#10;&#10;void Game::LoadSounds() {&#10;&#10;    mDeadChunk       = Mix_LoadWAV(&quot;../Assets/Sounds/Dead.wav&quot;);&#10;    mJumpChunk       = Mix_LoadWAV(&quot;../Assets/Sounds/Jump.wav&quot;);&#10;    mShootChunk   = Mix_LoadWAV(&quot;../Assets/Sounds/Laser_Shoot.wav&quot;);&#10;    mStageClearChunk = Mix_LoadWAV(&quot;../Assets/Sounds/StageClear.wav&quot;);&#10;    mGlitchChunk     = Mix_LoadWAV(&quot;../Assets/Sounds/Glitch.flac&quot;);&#10;&#10;    if (!mGlitchChunk) {&#10;        SDL_Log(&quot;Falha ao carregar Glitch.flac: %s&quot;, Mix_GetError());&#10;    }&#10;}&#10;&#10;void Game::PlayDeadChunk() {&#10;&#10;&#10;}&#10;&#10;void Game::PlayJumpChunk() const {&#10;&#10;    Mix_PlayChannel(-1, mJumpChunk, 0);&#10;}&#10;&#10;void Game::PlayShootChunk() const {&#10;&#10;    Mix_PlayChannel(-1, mShootChunk, 0);&#10;}&#10;&#10;void Game::PlayStageClearChunk() {&#10;&#10;&#10;}&#10;&#10;void Game::PlayGlitchChunk() const {&#10;    if (mGlitchChunk) {&#10;        Mix_PlayChannel(-1, mGlitchChunk, 0);&#10;    }&#10;}&#10;&#10;void Game::RunLoop()&#10;{&#10;    while (mIsRunning)&#10;    {&#10;        // Calculate delta time in seconds&#10;        float deltaTime = (SDL_GetTicks() - mTicksCount) / 1000.0f;&#10;        if (deltaTime &gt; 0.05f)&#10;        {&#10;            deltaTime = 0.05f;&#10;        }&#10;&#10;        mTicksCount = SDL_GetTicks();&#10;&#10;        ProcessInput();&#10;        UpdateGame(deltaTime);&#10;        GenerateOutput();&#10;&#10;        // Sleep to maintain frame rate&#10;        int sleepTime = (1000 / FPS) - (SDL_GetTicks() - mTicksCount);&#10;        if (sleepTime &gt; 0)&#10;        {&#10;            SDL_Delay(sleepTime);&#10;        }&#10;    }&#10;}&#10;&#10;void Game::ProcessInput()&#10;{&#10;    SDL_Event event;&#10;    while (SDL_PollEvent(&amp;event))&#10;    {&#10;        switch (event.type)&#10;        {&#10;            case SDL_QUIT:&#10;                Quit();&#10;                break;&#10;            case SDL_KEYDOWN:&#10;                if (!event.key.repeat){&#10;                    // Check for pause menu toggle first (only if in-game with only HUD)&#10;                    if (event.key.keysym.sym == SDLK_RETURN &amp;&amp; mRobot != nullptr){&#10;                        bool onlyHUD = true;&#10;                        for (auto* ui : mUIStack) {&#10;                            if (dynamic_cast&lt;HUD*&gt;(ui) == nullptr) {&#10;                                onlyHUD = false;&#10;                                break;&#10;                            }&#10;                        }&#10;                        if (onlyHUD) {&#10;                            mIsPaused = true;&#10;                            SetScene(GameScene::PauseMenu);&#10;                            break;&#10;                        }&#10;                    }&#10;                    // Let topmost UI handle key press&#10;                    if (!mUIStack.empty()){&#10;                        mUIStack.back()-&gt;HandleKeyPress(event.key.keysym.sym);&#10;                    }&#10;                }&#10;                break;&#10;        }&#10;    }&#10;&#10;    const Uint8* state = SDL_GetKeyboardState(nullptr);&#10;&#10;    for (auto actor : mActors)&#10;    {&#10;        actor-&gt;ProcessInput(state);&#10;    }&#10;}&#10;&#10;void Game::UpdateGame(float deltaTime)&#10;{&#10;    if (!mIsPaused &amp;&amp; !mIsSceneTransitioning) {&#10;        // Update all actors and pending actors&#10;        UpdateActors(deltaTime);&#10;&#10;        // Update audio system&#10;        if (mAudio) mAudio-&gt;Update(deltaTime);&#10;&#10;        // Check if Mario is dead&#10;        if (mRobot &amp;&amp; mRobot-&gt;IsDead()) {&#10;            SetScene(GameScene::GameOver);&#10;            return;&#10;        }&#10;&#10;        // Update camera position&#10;        UpdateCamera();&#10;    }&#10;&#10;    // Update UI screens (active ones)&#10;    for (auto ui : mUIStack) {&#10;        if (ui-&gt;GetState() == UIScreen::UIState::Active) {&#10;            ui-&gt;Update(deltaTime);&#10;        }&#10;    }&#10;&#10;    // Delete any UI that are closed&#10;    auto iter = mUIStack.begin();&#10;    while (iter != mUIStack.end()) {&#10;        if ((*iter)-&gt;GetState() == UIScreen::UIState::Closing) {&#10;            delete *iter;&#10;            iter = mUIStack.erase(iter);&#10;        } else {&#10;            ++iter;&#10;        }&#10;    }&#10;}&#10;&#10;void Game::UpdateActors(float deltaTime)&#10;{&#10;    mUpdatingActors = true;&#10;    for (auto actor : mActors)&#10;    {&#10;        actor-&gt;Update(deltaTime);&#10;    }&#10;    mUpdatingActors = false;&#10;&#10;    for (auto pending : mPendingActors)&#10;    {&#10;        mActors.emplace_back(pending);&#10;    }&#10;    mPendingActors.clear();&#10;&#10;    std::vector&lt;Actor*&gt; deadActors;&#10;    for (auto actor : mActors)&#10;    {&#10;        if (actor-&gt;GetState() == ActorState::Destroy)&#10;        {&#10;            if (std::find(deadActors.begin(), deadActors.end(), actor) == deadActors.end()) deadActors.emplace_back(actor);&#10;        }&#10;    }&#10;    for (auto actor : deadActors) {&#10;        const auto&amp; comps = actor-&gt;GetComponents();&#10;        SDL_Log(&quot;Deleting actor at %p, type=%s, numComponents=%zu&quot;, actor, actor-&gt;GetName(), comps.size());&#10;    }&#10;    for (auto actor : deadActors)&#10;    {&#10;        //SDL_Log(&quot;Deleting actor at %p, type=%s&quot;, actor, actor-&gt;GetName());&#10;        RemoveActor(actor);&#10;        delete actor;&#10;    }&#10;}&#10;&#10;void Game::UpdateCamera()&#10;{&#10;    if (!mRobot) {&#10;        return;&#10;    }&#10;&#10;    float robotX = mRobot-&gt;GetPosition().x;&#10;    float robotY = mRobot-&gt;GetPosition().y;&#10;&#10;    float targetX = robotX - WINDOW_WIDTH / 2.0f + TILE_SIZE / 2.0f;&#10;    float targetY = robotY - WINDOW_HEIGHT / 2.0f + TILE_SIZE / 2.0f;&#10;&#10;    if (targetX &gt; mCameraLeftBoundary)&#10;        mCameraLeftBoundary = targetX;&#10;&#10;    targetX = mCameraLeftBoundary;&#10;&#10;    float levelWidthInPixels = LEVEL_WIDTH * TILE_SIZE;&#10;    float levelHeightInPixels = LEVEL_HEIGHT * TILE_SIZE;&#10;&#10;    if (targetX &lt; 0) targetX = 0;&#10;    if (targetX &gt; levelWidthInPixels - WINDOW_WIDTH) targetX = levelWidthInPixels - WINDOW_WIDTH;&#10;&#10;    if (targetY &lt; 0) targetY = 0;&#10;    if (targetY &gt; levelHeightInPixels - WINDOW_HEIGHT) targetY = levelHeightInPixels - WINDOW_HEIGHT;&#10;&#10;    mCameraPos.x = targetX;&#10;    mCameraPos.y = targetY;&#10;}&#10;&#10;void Game::AddActor(Actor* actor)&#10;{&#10;    if (mUpdatingActors)&#10;    {&#10;        mPendingActors.emplace_back(actor);&#10;    }&#10;    else&#10;    {&#10;        mActors.emplace_back(actor);&#10;    }&#10;}&#10;&#10;void Game::RemoveActor(Actor* actor)&#10;{&#10;    auto iter = std::find(mPendingActors.begin(), mPendingActors.end(), actor);&#10;    if (iter != mPendingActors.end())&#10;    {&#10;        // Swap to end of vector and pop off (avoid erase copies)&#10;        std::iter_swap(iter, mPendingActors.end() - 1);&#10;        mPendingActors.pop_back();&#10;    }&#10;&#10;    iter = std::find(mActors.begin(), mActors.end(), actor);&#10;    if (iter != mActors.end())&#10;    {&#10;        // Swap to end of vector and pop off (avoid erase copies)&#10;        std::iter_swap(iter, mActors.end() - 1);&#10;        mActors.pop_back();&#10;    }&#10;}&#10;&#10;void Game::AddDrawable(class DrawComponent *drawable)&#10;{&#10;    mDrawables.emplace_back(drawable);&#10;&#10;    std::sort(mDrawables.begin(), mDrawables.end(),[](DrawComponent* a, DrawComponent* b) {&#10;        return a-&gt;GetDrawOrder() &lt; b-&gt;GetDrawOrder();&#10;    });&#10;}&#10;&#10;void Game::RemoveDrawable(class DrawComponent *drawable)&#10;{&#10;    auto iter = std::find(mDrawables.begin(), mDrawables.end(), drawable);&#10;    mDrawables.erase(iter);&#10;}&#10;&#10;void Game::AddCollider(class AABBColliderComponent* collider)&#10;{&#10;    mColliders.emplace_back(collider);&#10;}&#10;&#10;void Game::RemoveCollider(AABBColliderComponent* collider)&#10;{&#10;    auto iter = std::find(mColliders.begin(), mColliders.end(), collider);&#10;    mColliders.erase(iter);&#10;}&#10;&#10;void Game::GenerateOutput()&#10;{&#10;    // Clear back buffer&#10;    mRenderer-&gt;Clear();&#10;&#10;    //background drawing (only when in gameplay)&#10;    if (mRobot) {&#10;        Texture* bgTexture = mRenderer-&gt;GetTexture(&quot;../Assets/Sprites/Background.png&quot;);&#10;        if (bgTexture){&#10;            Vector2 size(LEVEL_WIDTH * TILE_SIZE, LEVEL_HEIGHT * TILE_SIZE);&#10;&#10;            Vector2 topLeft = Vector2(LEVEL_WIDTH * TILE_SIZE / 2.0f, LEVEL_HEIGHT * TILE_SIZE / 2.0f);&#10;            mRenderer-&gt;DrawTexture(topLeft, size, 0.0f, Vector3::One, bgTexture, Vector4::UnitRect, mCameraPos, false);&#10;        }&#10;    }&#10;&#10;    for (auto drawable : mDrawables)&#10;    {&#10;        drawable-&gt;Draw(mRenderer);&#10;&#10;        if(mIsDebugging)&#10;        {&#10;           // Call draw for actor components&#10;              for (auto comp : drawable-&gt;GetOwner()-&gt;GetComponents())&#10;              {&#10;                comp-&gt;DebugDraw(mRenderer);&#10;              }&#10;        }&#10;    }&#10;&#10;    // Draw UI elements&#10;    mRenderer-&gt;Draw();&#10;&#10;    // Swap front buffer and back buffer&#10;    mRenderer-&gt;Present();&#10;}&#10;&#10;void Game::Shutdown()&#10;{&#10;    // Delete actors (destructors should call RemoveActor safely)&#10;    while (!mActors.empty()) {&#10;        delete mActors.back();&#10;    }&#10;&#10;    // Delete UI screens&#10;    for (auto ui : mUIStack) {&#10;        delete ui;&#10;    }&#10;    mUIStack.clear();&#10;&#10;    // Delete level data if still present&#10;    if (mLevelData) {&#10;        for (int i = 0; i &lt; LEVEL_HEIGHT; ++i) {&#10;            delete[] mLevelData[i];&#10;        }&#10;        delete[] mLevelData;&#10;        mLevelData = nullptr;&#10;    }&#10;&#10;    // Renderer cleanup&#10;    if (mRenderer) {&#10;        mRenderer-&gt;Shutdown();&#10;        delete mRenderer;&#10;        mRenderer = nullptr;&#10;    }&#10;&#10;    // Audio cleanup&#10;    if (mAudio) {&#10;        delete mAudio;&#10;        mAudio = nullptr;&#10;    }&#10;&#10;    if (mWindow) {&#10;        SDL_DestroyWindow(mWindow);&#10;        mWindow = nullptr;&#10;    }&#10;&#10;    Mix_FreeChunk(mDeadChunk);&#10;    Mix_FreeChunk(mJumpChunk);&#10;    Mix_FreeChunk(mShootChunk);&#10;    Mix_FreeChunk(mStageClearChunk);&#10;    Mix_FreeChunk(mGlitchChunk);&#10;&#10;    Mix_CloseAudio();&#10;&#10;    SDL_Quit();&#10;}&#10;&#10;void Game::SpawnRandomGoldRings(int quantidade, int width, int height, int** levelData) {&#10;    int tentativas = 0;&#10;    int maxTentativas = quantidade * 10;&#10;    int ringsCriados = 0;&#10;    while (ringsCriados &lt; quantidade &amp;&amp; tentativas &lt; maxTentativas) {&#10;        int col = rand() % width;&#10;        int row = rand() % height;&#10;        if (levelData[row][col] == -1) { // Tile vazio&#10;            Vector2 pos(col * TILE_SIZE + TILE_SIZE * 0.5f, row * TILE_SIZE + TILE_SIZE * 0.5f);&#10;            GoldRing* ring = new GoldRing(this);&#10;            ring-&gt;SetPosition(pos);&#10;            ringsCriados++;&#10;        }&#10;        tentativas++;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>